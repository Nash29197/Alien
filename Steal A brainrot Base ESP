local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "Steal a brainrot | by 三眼怪",
    LoadingTitle = "Nash Hub",
    LoadingSubtitle = "by 三眼怪",
    ShowText = "Rayfield",
    Theme = "Default",
    ToggleUIKeybind = Enum.KeyCode.K,
    ConfigurationSaving = {
        Enabled = true,
        FileName = "Nash Hub"
    }
})

local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local player = Players.LocalPlayer

-- 等待角色完全加載
if not game:IsLoaded() then game.Loaded:Wait() end
repeat task.wait() until player.Character and player.Character:FindFirstChild("Humanoid")

local CombatTab = Window:CreateTab("戰鬥", 0)

local KillAuraActive = false
local KillAuraConnection = nil
local KillAuraDistance = 20
local toolName = "Tung Bat"

local function startKillAura()
    if KillAuraActive then return end
    KillAuraActive = true

    KillAuraConnection = RunService.Heartbeat:Connect(function()
        pcall(function()
            local char = player.Character
            if not char or not char:FindFirstChild("HumanoidRootPart") then return end

            local tool = player.Backpack:FindFirstChild(toolName) or char:FindFirstChild(toolName)
            if not tool then return end

            local nearbyPlayers = {}
            for _, otherPlayer in pairs(Players:GetPlayers()) do
                if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local dist = (otherPlayer.Character.HumanoidRootPart.Position - char.HumanoidRootPart.Position).Magnitude
                    if dist <= KillAuraDistance then
                        table.insert(nearbyPlayers, {player = otherPlayer, distance = dist})
                    end
                end
            end

            table.sort(nearbyPlayers, function(a, b) return a.distance < b.distance end)

            for i = 1, math.min(#nearbyPlayers, 3) do
                local target = nearbyPlayers[i].player
                local targetChar = target.Character
                local targetHRP = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
                if targetHRP then
                    local dir = (targetHRP.Position - char.HumanoidRootPart.Position).Unit
                    local lookDir = Vector3.new(dir.X, 0, dir.Z)
                    char.HumanoidRootPart.CFrame = CFrame.lookAt(char.HumanoidRootPart.Position, char.HumanoidRootPart.Position + lookDir)

                    if tool.Parent == player.Backpack then
                        char.Humanoid:EquipTool(tool)
                    end

                    if tool:FindFirstChild("Handle") then
                        tool:Activate()
                    end

                    task.wait(0.05)
                end
            end
        end)
    end)
end

local function stopKillAura()
    if KillAuraConnection then
        KillAuraConnection:Disconnect()
        KillAuraConnection = nil
    end
    KillAuraActive = false
end

player.CharacterAdded:Connect(function()
    task.wait(1)
    if KillAuraActive then
        startKillAura()
    end
end)

CombatTab:CreateToggle({
    Name = "自動攻擊 (KillAura)",
    CurrentValue = false,
    Callback = function(value)
        if value then
            startKillAura()
        else
            stopKillAura()
        end
    end,
})

CombatTab:CreateSlider({
    Name = "攻擊距離",
    Range = {1, 100},
    Increment = 1,
    Suffix = " studs",
    CurrentValue = KillAuraDistance,
    Callback = function(value)
        KillAuraDistance = value
    end,
})

local MainTab = Window:CreateTab("玩家", 0)

-- WalkSpeed 功能
local HumanModCons = {}

local function setWalkSpeed(speed)
    local Char = player.Character or workspace:FindFirstChild(player.Name)
    local Human = Char and Char:FindFirstChildWhichIsA("Humanoid")

    local function WalkSpeedChange()
        if Char and Human then
            Human.WalkSpeed = speed
        end
    end

    WalkSpeedChange()

    if HumanModCons.wsLoop then HumanModCons.wsLoop:Disconnect() end
    if HumanModCons.wsCA then HumanModCons.wsCA:Disconnect() end

    if Human then
        HumanModCons.wsLoop = Human:GetPropertyChangedSignal("WalkSpeed"):Connect(WalkSpeedChange)
    end

    HumanModCons.wsCA = player.CharacterAdded:Connect(function(nChar)
        Char = nChar
        Human = nChar:WaitForChild("Humanoid")
        WalkSpeedChange()
        if HumanModCons.wsLoop then HumanModCons.wsLoop:Disconnect() end
        HumanModCons.wsLoop = Human:GetPropertyChangedSignal("WalkSpeed"):Connect(WalkSpeedChange)
    end)
end

local function resetWalkSpeed()
    local Char = player.Character or workspace:FindFirstChild(player.Name)
    local Human = Char and Char:FindFirstChildWhichIsA("Humanoid")
    if Human then
        Human.WalkSpeed = 16
    end
    if HumanModCons.wsLoop then HumanModCons.wsLoop:Disconnect() end
    if HumanModCons.wsCA then HumanModCons.wsCA:Disconnect() end
end

MainTab:CreateToggle({
    Name = "速度MAX",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            setWalkSpeed(50)
        else
            resetWalkSpeed()
        end
    end,
})

-- JumpHeight 功能
local function setJumpHeight(height)
    local Char = player.Character or workspace:FindFirstChild(player.Name)
    local Human = Char and Char:FindFirstChildWhichIsA("Humanoid")

    local function JumpHeightChange()
        if Char and Human then
            Human.JumpHeight = height
        end
    end

    JumpHeightChange()

    if HumanModCons.jhLoop then HumanModCons.jhLoop:Disconnect() end
    if HumanModCons.jhCA then HumanModCons.jhCA:Disconnect() end

    if Human then
        HumanModCons.jhLoop = Human:GetPropertyChangedSignal("JumpHeight"):Connect(JumpHeightChange)
    end

    HumanModCons.jhCA = player.CharacterAdded:Connect(function(nChar)
        Char = nChar
        Human = nChar:WaitForChild("Humanoid")
        JumpHeightChange()
        if HumanModCons.jhLoop then HumanModCons.jhLoop:Disconnect() end
        HumanModCons.jhLoop = Human:GetPropertyChangedSignal("JumpHeight"):Connect(JumpHeightChange)
    end)
end

local function resetJumpHeight()
    local Char = player.Character or workspace:FindFirstChild(player.Name)
    local Human = Char and Char:FindFirstChildWhichIsA("Humanoid")
    if Human then
        Human.JumpHeight = 7.2 -- 預設值
    end
    if HumanModCons.jhLoop then HumanModCons.jhLoop:Disconnect() end
    if HumanModCons.jhCA then HumanModCons.jhCA:Disconnect() end
end

MainTab:CreateToggle({
    Name = "跳躍MAX",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            setJumpHeight(14.4) -- 加倍跳躍
        else
            resetJumpHeight()
        end
    end,
})

-- 低重力功能
local lowGravity = 150 -- 低重力數值
local BodyForceName = "LowGravityForce"

local function applyLowGravity()
    local character = player.Character or player.CharacterAdded:Wait()
    local hrp = character:WaitForChild("HumanoidRootPart")

    if hrp:FindFirstChild(BodyForceName) then
        hrp[BodyForceName]:Destroy()
    end

    local bodyForce = Instance.new("BodyForce")
    bodyForce.Name = BodyForceName

    local gravityForce = Vector3.new(0, workspace.Gravity * hrp:GetMass(), 0)
    local gravityScale = lowGravity / workspace.Gravity
    bodyForce.Force = gravityForce * (1 - gravityScale)
    bodyForce.Parent = hrp
end

local function resetGravity()
    local character = player.Character or player.CharacterAdded:Wait()
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp and hrp:FindFirstChild(BodyForceName) then
        hrp[BodyForceName]:Destroy()
    end
end

MainTab:CreateToggle({
    Name = "低重力",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            applyLowGravity()
            -- 修正判斷是否已連接 CharacterAdded 事件
            if not player.CharacterAdded.ConnectApplied then
                player.CharacterAdded:Connect(function()
                    wait(1)
                    applyLowGravity()
                end)
                player.CharacterAdded.ConnectApplied = true
            end
        else
            resetGravity()
        end
    end,
})

-- 無限跳功能
local jumpConnection = nil
local function setInfiniteJump(enabled)
    if enabled then
        jumpConnection = UserInputService.JumpRequest:Connect(function()
            local Char = player.Character
            local Humanoid = Char and Char:FindFirstChildOfClass("Humanoid")
            if Humanoid then
                Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end)
    else
        if jumpConnection then jumpConnection:Disconnect() jumpConnection = nil end
    end
end

MainTab:CreateToggle({
    Name = "無限跳躍",
    CurrentValue = false,
    Callback = function(Value)
        setInfiniteJump(Value)
    end,
})

-- 無敵模式功能
local godModeToggle = false
local godConnections = {}
local godHeartbeat

local function enableGodMode()
    local function apply(character)
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end

        humanoid.BreakJointsOnDeath = false
        humanoid.RequiresNeck = false

        for _, conn in ipairs(getconnections(humanoid.Died)) do
            conn:Disable()
            table.insert(godConnections, conn)
        end

        table.insert(godConnections, humanoid:GetPropertyChangedSignal("Health"):Connect(function()
            if humanoid.Health < humanoid.MaxHealth then
                humanoid.Health = humanoid.MaxHealth
            end
        end))

        godHeartbeat = RunService.Heartbeat:Connect(function()
            if humanoid and humanoid.Health < humanoid.MaxHealth then
                humanoid.Health = humanoid.MaxHealth
            end
        end)
    end

    apply(player.Character or player.CharacterAdded:Wait())
    table.insert(godConnections, player.CharacterAdded:Connect(function(char)
        task.wait(0.5)
        apply(char)
    end))
end

local function disableGodMode()
    for _, conn in ipairs(godConnections) do
        if typeof(conn) == "RBXScriptConnection" then conn:Disconnect() end
    end
    godConnections = {}

    if godHeartbeat then godHeartbeat:Disconnect() godHeartbeat = nil end

    local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.BreakJointsOnDeath = true
        humanoid.RequiresNeck = true
    end
end

MainTab:CreateToggle({
    Name = "無敵模式",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            enableGodMode()
        else
            disableGodMode()
        end
    end,
})

-- 視覺 Tab (ESP)
local VisionTab = Window:CreateTab("視覺", 0)

local playerESPEnabled = false
local playerESPConnections = {}
local playerESPList = {}
local espColor = Color3.fromRGB(0, 255, 0)

local function clearPlayerESP()
    for char, _ in pairs(playerESPList) do
        if char and char.Parent then
            local hl = char:FindFirstChild("ESP_Highlight")
            if hl then hl:Destroy() end

            for _, part in ipairs(char:GetChildren()) do
                if part:IsA("BasePart") then
                    local bb = part:FindFirstChild("ESP_NameTag")
                    if bb then bb:Destroy() end
                end
            end
        end
        playerESPList[char] = nil
    end
end

local function applyPlayerESP(character, player)
    if not character or not player or player == Players.LocalPlayer then return end
    if playerESPList[character] then return end
    playerESPList[character] = true

    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_Highlight"
    highlight.FillColor = espColor
    highlight.FillTransparency = 0.25
    highlight.OutlineColor = espColor
    highlight.OutlineTransparency = 0
    highlight.Adornee = character
    highlight.Parent = character

    local adorneePart = character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")
    if adorneePart then
        local bb = Instance.new("BillboardGui")
        bb.Name = "ESP_NameTag"
        bb.Size = UDim2.new(0, 100, 0, 24)
        bb.StudsOffset = Vector3.new(0, 2.5, 0)
        bb.AlwaysOnTop = true
        bb.Adornee = adorneePart
        bb.Parent = adorneePart

        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.Text = player.DisplayName
        label.TextColor3 = espColor
        label.TextStrokeColor3 = Color3.new(0, 0, 0)
        label.TextStrokeTransparency = 0.5
        label.TextScaled = true
        label.Font = Enum.Font.GothamBold
        label.Parent = bb
    end
end

local function startPlayerESP()
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= Players.LocalPlayer and p.Character then
            applyPlayerESP(p.Character, p)
        end
    end

    table.insert(playerESPConnections, Players.PlayerAdded:Connect(function(p)
        table.insert(playerESPConnections, p.CharacterAdded:Connect(function(char)
            task.wait(1)
            if playerESPEnabled then
                applyPlayerESP(char, p)
            end
        end))
    end))

    table.insert(playerESPConnections, RunService.RenderStepped:Connect(function()
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= Players.LocalPlayer and p.Character then
                applyPlayerESP(p.Character, p)
            end
        end
    end))
end

local function stopPlayerESP()
    clearPlayerESP()
    for _, c in ipairs(playerESPConnections) do
        if typeof(c) == "RBXScriptConnection" then c:Disconnect() end
    end
    playerESPConnections = {}
end

VisionTab:CreateToggle({
    Name = "ESP玩家",
    CurrentValue = false,
    Callback = function(Value)
        playerESPEnabled = Value
        if Value then
            startPlayerESP()
        else
            stopPlayerESP()
        end
    end,
})

local plotTimers_Enabled = false
local plotTimers_Coroutine = nil
local plotTimers_RenderConnections = {}
local plotTimers_OriginalProperties = {}

local function disablePlotTimers()
    plotTimers_Enabled = false
    if plotTimers_Coroutine then
        task.cancel(plotTimers_Coroutine)
        plotTimers_Coroutine = nil
    end

    for _, conn in pairs(plotTimers_RenderConnections) do
        pcall(function() conn:Disconnect() end)
    end
    table.clear(plotTimers_RenderConnections)

    for label, props in pairs(plotTimers_OriginalProperties) do
        pcall(function()
            if label and label.Parent then
                local bb = label:FindFirstAncestorWhichIsA("BillboardGui")
                if bb and bb.Parent then
                    bb.Enabled = props.bb_enabled
                    bb.AlwaysOnTop = props.bb_alwaysOnTop
                    bb.Size = props.bb_size
                    bb.MaxDistance = props.bb_maxDistance

                    label.TextScaled = props.label_textScaled
                    label.TextWrapped = props.label_textWrapped
                    label.AutomaticSize = props.label_automaticSize
                    label.Size = props.label_size
                    label.TextSize = props.label_textSize
                end
            end
        end)
    end
end

local function enablePlotTimers()
    disablePlotTimers()

    plotTimers_Enabled = true
    plotTimers_Coroutine = task.spawn(function()
        local camera = workspace.CurrentCamera
        local DISTANCE_THRESHOLD = 45
        local SCALE_START, SCALE_RANGE = 100, 300
        local MIN_TEXT_SIZE, MAX_TEXT_SIZE = 30, 36

        while plotTimers_Enabled do
            pcall(function()
                for _, label in ipairs(workspace.Plots:GetDescendants()) do
                    task.spawn(function()
                        if not label:IsA("TextLabel") or label.Name ~= "RemainingTime" then return end
                        if plotTimers_RenderConnections[label] then return end

                        local bb = label:FindFirstAncestorWhichIsA("BillboardGui")
                        if not bb then return end

                        local model = bb:FindFirstAncestorWhichIsA("Model")
                        if not model then return end

                        local basePart = model:FindFirstChildWhichIsA("BasePart", true)
                        if not basePart then return end

                        if not plotTimers_OriginalProperties[label] then
                            plotTimers_OriginalProperties[label] = {
                                bb_enabled = bb.Enabled,
                                bb_alwaysOnTop = bb.AlwaysOnTop,
                                bb_size = bb.Size,
                                bb_maxDistance = bb.MaxDistance,
                                label_textScaled = label.TextScaled,
                                label_textWrapped = label.TextWrapped,
                                label_automaticSize = label.AutomaticSize,
                                label_size = label.Size,
                                label_textSize = label.TextSize,
                            }
                        end

                        bb.MaxDistance = 10000
                        bb.AlwaysOnTop = true
                        bb.ClipsDescendants = false
                        bb.Size = UDim2.new(0, 300, 0, 150)

                        label.TextScaled = false
                        label.TextWrapped = true
                        label.ClipsDescendants = false
                        label.Size = UDim2.new(1, 0, 0, 32)
                        label.AutomaticSize = Enum.AutomaticSize.Y

                        local conn = game:GetService("RunService").RenderStepped:Connect(function()
                            if not basePart or not basePart.Parent or not bb or not bb.Parent then
                                if plotTimers_RenderConnections[label] then
                                    plotTimers_RenderConnections[label]:Disconnect()
                                    plotTimers_RenderConnections[label] = nil
                                end
                                return
                            end

                            local distance = (camera.CFrame.Position - basePart.Position).Magnitude
                            if distance > DISTANCE_THRESHOLD and basePart.Position.Y >= 0 then
                                bb.Enabled = false
                                return
                            end

                            bb.Enabled = true
                            local t = math.clamp((distance - SCALE_START) / SCALE_RANGE, 0, 1)
                            local newTextSize = math.clamp(MIN_TEXT_SIZE + (MAX_TEXT_SIZE - MIN_TEXT_SIZE) * t, MIN_TEXT_SIZE, MAX_TEXT_SIZE)
                            label.TextSize = newTextSize
                            label.Size = UDim2.new(1, 0, 0, newTextSize + 6)
                        end)
                        plotTimers_RenderConnections[label] = conn
                    end)
                end
            end)
            task.wait(1)
        end
    end)
end

VisualsPage:CreateToggle({
    Name = "ESP房子時間",
    CurrentValue = false,
    Flag = "ShowPlotTimers",
    Callback = function(state)
        if state then
            enablePlotTimers()
        else
            disablePlotTimers()
        end
    end,
})

-- ESP 高亮色與稀有度對應色
local highlightColor = Color3.fromRGB(255, 0, 0)
local qualityColors = {
    ["Common"] = Color3.fromRGB(255, 255, 255),
    ["Rare"] = Color3.fromRGB(30, 144, 255),
    ["Epic"] = Color3.fromRGB(148, 0, 211),
    ["Legendary"] = Color3.fromRGB(255, 215, 0),
    ["Mythic"] = Color3.fromRGB(255, 0, 0),
    ["Brainrot God"] = Color3.fromRGB(255, 105, 180),
    ["Secret"] = Color3.fromRGB(0, 0, 0),
}

-- 從 GitHub 載入分類表
local function loadTargetsFromURL(url)
    local success, content = pcall(function()
        return game:HttpGet(url)
    end)
    if success and content then
        local chunk = loadstring(content)
        if typeof(chunk) == "function" then
            local ok, result = pcall(chunk)
            if ok and typeof(result) == "table" then
                return result
            end
        end
    end
    warn("無法載入 Targets，使用空表")
    return {}
end

local GitHubURL = "https://raw.githubusercontent.com/Nash29197/Nash-Hub/main/Steal%20a%20brainrot%20List.lua"
local Targets = loadTargetsFromURL(GitHubURL)

-- 稀有度開關設定
getgenv().Rarity = getgenv().Rarity or {}
local ESPMarked = {}

-- 清除所有 ESP
local function clearAllESP()
    for obj, _ in pairs(ESPMarked) do
        if obj and obj.Parent then
            local hl = obj:FindFirstChild("ESP_Highlight")
            if hl then hl:Destroy() end

            for _, part in ipairs(obj:GetDescendants()) do
                if part:IsA("BasePart") then
                    local billboard = part:FindFirstChild("ESP_NameTag")
                    if billboard then billboard:Destroy() end
                end
            end
        end
        ESPMarked[obj] = nil
    end
end

-- 判斷是否應標記該物件
local function shouldApplyESP(obj)
    if not obj or not obj:IsA("Model") then return false end
    local data = Targets[obj.Name]
    if not data then return false end
    local rarity = data.quality
    if not getgenv().Rarity[rarity] or not getgenv().Rarity[rarity].enabled then return false end
    return true
end

-- 標記 ESP
local function applyESP(obj)
    if ESPMarked[obj] then return end
    if not shouldApplyESP(obj) then return end

    ESPMarked[obj] = true

    -- 清除舊 ESP
    if obj:FindFirstChild("ESP_Highlight") then obj.ESP_Highlight:Destroy() end
    for _, part in ipairs(obj:GetDescendants()) do
        if part:IsA("BasePart") then
            local billboard = part:FindFirstChild("ESP_NameTag")
            if billboard then billboard:Destroy() end
        end
    end

    -- Highlight
    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_Highlight"
    highlight.FillColor = highlightColor
    highlight.FillTransparency = 0
    highlight.OutlineColor = Color3.new(1, 1, 1)
    highlight.OutlineTransparency = 0
    highlight.Adornee = obj
    highlight.Parent = obj

    -- 找適合的 adorneePart（用於掛載 BillboardGui）
    local adorneePart = obj:FindFirstChild("HumanoidRootPart")

    if not adorneePart then
        if obj.PrimaryPart then
            adorneePart = obj.PrimaryPart
        else
            local highestY = -math.huge
            for _, part in ipairs(obj:GetDescendants()) do
                if part:IsA("BasePart") and part.Position.Y > highestY then
                    highestY = part.Position.Y
                    adorneePart = part
                end
            end
        end
    end

    -- 如果還是沒找到，就創建一個透明零件掛載
    if not adorneePart then
        adorneePart = Instance.new("Part")
        adorneePart.Name = "TempESPPart"
        adorneePart.Size = Vector3.new(1,1,1)
        adorneePart.Transparency = 1
        adorneePart.Anchored = true
        adorneePart.CanCollide = false
        adorneePart.CFrame = obj:GetPivot()
        adorneePart.Parent = obj
    end

    -- 建立 BillboardGui 名稱標籤
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP_NameTag"
    billboard.Size = UDim2.new(0, 120, 0, 24)
    billboard.StudsOffset = Vector3.new(0, 2.5, 0)
    billboard.AlwaysOnTop = true
    billboard.Adornee = adorneePart
    billboard.Parent = adorneePart

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = obj.Name
    label.TextColor3 = qualityColors[Targets[obj.Name].quality] or Color3.new(1,1,1)
    label.TextStrokeColor3 = Color3.new(0,0,0)
    label.TextStrokeTransparency = 0.5
    label.TextScaled = true
    label.Font = Enum.Font.GothamBold
    label.Parent = billboard
end

-- 刷新所有 ESP
local function refreshAllESP()
    clearAllESP()
    for _, obj in ipairs(workspace:GetDescendants()) do
        if shouldApplyESP(obj) then
            applyESP(obj)
        end
    end
end

-- Rayfield UI 下拉式選單 (假設你有 VisionTab 變數指向該頁籤)
VisionTab:CreateDropdown({
    Name = "ESP腦腐",
    Options = {"Secret", "Brainrot God", "Mythic", "Legendary", "Epic", "Rare", "Common"},
    CurrentOption = {},
    MultipleOptions = true,
    Flag = "ESP腦腐",
    Callback = function(Options)
        for _, rarity in ipairs({"Secret", "Brainrot God", "Mythic", "Legendary", "Epic", "Rare", "Common"}) do
            getgenv().Rarity[rarity] = {enabled = table.find(Options, rarity) ~= nil}
        end
        refreshAllESP()
    end
})

-- 自動標記新增模型
workspace.DescendantAdded:Connect(function(obj)
    if obj:IsA("Model") then
        task.delay(0.3, function()
            if shouldApplyESP(obj) then
                applyESP(obj)
            end
        end)
    end
end)

-- 定時刷新（防止斷線或物件延遲出現）
task.spawn(function()
    while true do
        refreshAllESP()
        task.wait(1)
    end
end)

-- 商店 Tab
local ShopTab = Window:CreateTab("商店", 0)

-- 遠端載入商店物品清單
local function loadShopItemsFromURL(url)
    local success, content = pcall(function()
        return game:HttpGet(url)
    end)
    if success and content then
        local chunk = loadstring(content)
        if typeof(chunk) == "function" then
            local ok, result = pcall(chunk)
            if ok and typeof(result) == "table" then
                return result
            end
        end
    end
    warn("無法載入商店物品清單，使用空表")
    return {}
end

local ShopItemsURL = "https://raw.githubusercontent.com/Nash29197/Nash-Hub/main/Steal%20a%20brainrot%20Shop%20Items.lua"
local ShopItems = loadShopItemsFromURL(ShopItemsURL)

-- 狀態變數
local selectedItems = {}
local trapCount = 1
local autoBuyEnabled = false
local isBuying = false
local buyRequestPending = false

-- 資源與服務
local RepStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local buyRemote = RepStorage:WaitForChild("Packages"):WaitForChild("Net"):WaitForChild("RF/CoinsShopService/RequestBuy")
local player = Players.LocalPlayer
local backpack = player:WaitForChild("Backpack")
local character = player.Character or player.CharacterAdded:Wait()

-- 延遲配置
local purchaseDelays = {
    ["Grapple Hook"] = 0.2,
    ["Trap"] = 0.2,
    ["Speed Coil"] = 0.2,
}
local defaultDelay = 0.4

-- 計算物品數量（背包 + 身上）
local function countItemInInventory(itemName)
    task.wait(0.1)
    local count = 0
    for _, item in ipairs(backpack:GetChildren()) do
        if item.Name == itemName then
            count = count + 1
        end
    end
    for _, item in ipairs(character:GetChildren()) do
        if item.Name == itemName then
            count = count + 1
        end
    end
    return count
end

-- 安全購買單個物品
local function safeInvoke(itemName)
    local success, err = pcall(function()
        buyRemote:InvokeServer(itemName)
    end)
    if not success then warn("購買失敗:", itemName, err) end
    return success
end

-- 購買多個（1~N）物品
local function buyItem(item, count)
    count = count or 1
    for i = 1, count do
        if not autoBuyEnabled then break end
        safeInvoke(item)
        task.wait(purchaseDelays[item] or defaultDelay)
    end
end

-- 檢查是否所有已選物品皆滿足需求
local function allItemsBought()
    for _, item in ipairs(ShopItems) do
        if table.find(selectedItems, item) then
            local currentCount = countItemInInventory(item)
            if item == "Trap" then
                if currentCount < math.min(trapCount, 5) then return false end
            elseif item == "Grapple Hook" then
                if currentCount < 5 then return false end
            elseif currentCount < 1 then
                return false
            end
        end
    end
    return true
end

-- 主購買流程
local function buySelectedItemsSequential()
    if isBuying then
        buyRequestPending = true
        return
    end
    isBuying = true
    task.spawn(function()
        while autoBuyEnabled do
            for _, item in ipairs(ShopItems) do
                if not autoBuyEnabled then break end
                if table.find(selectedItems, item) then
                    local currentCount = countItemInInventory(item)
                    if item == "Trap" then
                        local need = math.min(trapCount, 5)
                        if currentCount < need then
                            buyItem(item, need - currentCount)
                        end
                    elseif item == "Grapple Hook" then
                        if currentCount < 5 then
                            buyItem(item, 5 - currentCount)
                        end
                    elseif currentCount < 1 then
                        buyItem(item, 1)
                    end
                end
            end

            if allItemsBought() then break end
            task.wait(0.5)
        end

        isBuying = false
        if buyRequestPending and autoBuyEnabled then
            buyRequestPending = false
            buySelectedItemsSequential()
        end
    end)
end

-- ========= 📦 UI 建構區塊（請配合你的 Rayfield ShopTab 使用） =========

ShopTab:CreateDropdown({
    Name = "道具列表(可複選)",
    Options = (function()
        local opts = table.clone(ShopItems)
        table.insert(opts, 1, "All")
        return opts
    end)(),
    CurrentOption = {},
    MultipleOptions = true,
    Flag = "DropdownAutoBuy",
    Callback = function(Options)
        if table.find(Options, "All") then
            selectedItems = table.clone(ShopItems)
            if library and library.flags then
                library.flags["DropdownAutoBuy"] = selectedItems
            end
        else
            selectedItems = Options
        end
        if autoBuyEnabled then
            buySelectedItemsSequential()
        end
    end,
})

ShopTab:CreateSlider({
    Name = "夾子購買數量(1~5)",
    Range = {1,5}, Increment = 1, Suffix = "個",
    CurrentValue = trapCount,
    Flag = "TrapSlider",
    Callback = function(v)
        trapCount = v
        if autoBuyEnabled then buySelectedItemsSequential() end
    end
})

ShopTab:CreateToggle({
    Name = "自動購買",
    CurrentValue = false,
    Flag = "ToggleAutoBuy",
    Callback = function(v)
        autoBuyEnabled = v
        if v then buySelectedItemsSequential() end
    end
})

local DevelopersTab = Window:CreateTab("開發者工具", 0)

DevelopersTab:CreateButton({
    Name = "Infinite Yield",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
    end,
})

DevelopersTab:CreateButton({
    Name = "DEX",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/DarkNetworks/Infinite-Yield/refs/heads/main/dex.lua'))()
    end,
})

DevelopersTab:CreateButton({
    Name = "SimpleSpy",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/DarkNetworks/Infinite-Yield/refs/heads/main/SimpleSpyV3/main.lua'))()
    end,
})

Rayfield:LoadConfiguration()
